# ZisK Private Value Example

This project demonstrates how to structure, process, and use **public and private inputs** in a cryptographic computation, using a preprocessor and a clear separation of concerns. The example hashes a private value a public number of times, outputting only the result.

---

## Table of Contents
- [Overview](#overview)
- [Project Structure](#project-structure)
- [Input Structure](#input-structure)
- [Flow: From Input to Output](#flow-from-input-to-output)
- [Execution Flow: Build, Preprocess, and Main](#execution-flow-build-preprocess-and-main)
- [How Private Values Are Handled](#how-private-values-are-handled)
- [Setup & Usage](#setup--usage)
- [Code Walkthrough](#code-walkthrough)
- [Security Notes](#security-notes)

---

## Overview

- **Public input:** Number of hash rounds (`n`)
- **Private input:** A secret value (string, padded/truncated to 32 bytes)
- **Goal:** Hash the private value `n` times using SHA-256, and output the final hash (split into 8 public values).
- **Privacy:** The secret is never revealed in outputs or public files.

---

## Project Structure

```
sha_hasher/
├── build.rs
├── Cargo.toml
├── input.json         # Structured input (public & private)
├── input.bin          # Binary input (public + private, for program)
├── public.json        # Public input only (for verifiers)
├── src/
│   ├── main.rs        # Main program logic
│   └── bin/
│       └── preprocess.rs  # Preprocessor: JSON → bin & public.json
└── ...
```

---

## Input Structure

Inputs are defined in `input.json`:

```json
{
  "public": {
    "n": 5
  },
  "private": {
    "secret": "my secret message"
  }
}
```
- **`public.n`**: Number of hash rounds (public, declared in `public.json`)
- **`private.secret`**: Secret value (private, never revealed)

---

## input.bin Storage Format

When you run the preprocessor, it writes the inputs to `input.bin` in a specific binary format:

| Offset | Length (bytes) | Field   | Source   | Description                                 |
|--------|----------------|---------|----------|---------------------------------------------|
| 0      | 8              | `n`     | public   | Number of hash rounds (little-endian u64)   |
| 8      | 32             | `secret`| private  | Secret value (padded/truncated to 32 bytes) |

- **First 8 bytes:** The public input `n`, encoded as a 64-bit unsigned integer in little-endian format.
- **Next 32 bytes:** The private input `secret`, encoded as bytes, padded with zeros or truncated to exactly 32 bytes.

### Example
Suppose your `input.json` is:
```json
{
  "public": { "n": 5 },
  "private": { "secret": "my secret message" }
}
```
- The number `5` is stored as 8 bytes: `[0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]`
- The string `"my secret message"` is converted to bytes, and padded with zeros to make 32 bytes.

So, `input.bin` will look like:
```
[n as 8 bytes][secret as 32 bytes]
```

### How the Program Reads It
- The main program reads the first 8 bytes and interprets them as `n`.
- It reads the next 32 bytes and uses them as the starting value for the hash.

**Code:**
```rust
let n = u64::from_le_bytes(input[0..8].try_into().unwrap());
let mut hash = [0u8; 32];
hash.copy_from_slice(&input[8..40]);
```

**Summary Table:**
| Bytes         | Meaning         | How to Read in Rust                        |
|---------------|----------------|--------------------------------------------|
| 0..8          | Public input n  | `u64::from_le_bytes(&input[0..8])`         |
| 8..40         | Private secret  | `input[8..40]` as `[u8; 32]`               |

---

## public.json Purpose and Usage

- `public.json` is generated by the preprocessor and contains only the public fields from your `input.json` (e.g., the number of hash rounds `n`).
- **It is not used by the main program (`main.rs`) during execution.**
- Its main purposes are:
  - **Transparency:** Allows anyone to see what public inputs were used for a computation, without revealing private data.
  - **Auditing:** Serves as a record for verifiers or auditors to check the public parameters of a run.
  - **Verification:** In privacy-preserving or zero-knowledge workflows, verifiers use `public.json` to check proofs against the public inputs.
  - **Documentation:** Provides a clear, machine-readable record of public inputs for reproducibility.

**Summary Table:**
| File         | Used by main.rs? | Purpose                                      |
|--------------|------------------|----------------------------------------------|
| input.bin    | Yes              | Binary input for computation (public+private) |
| public.json  | No               | Record of public inputs for transparency      |

---

## Flow: From Input to Output

1. **Define Inputs**: Edit `input.json` with your public and private values.
2. **Preprocess**: Run the preprocessor to generate `input.bin` and `public.json`:
   - `input.bin` = `[n (8 bytes, little-endian)] + [secret (32 bytes, padded/truncated)]`
   - `public.json` = `{ "n": ... }`
3. **Execution**: Run the main program, which:
   - Reads `input.bin`
   - Uses `n` as the number of hash rounds (public)
   - Uses the secret as the starting value for hashing (private)
   - Hashes the secret `n` times
   - Outputs the final hash (split into 8 public values)

---

## Execution Flow: Build, Preprocess, and Main

1. **Preprocessing (`preprocess.rs`)**
   - You manually run the preprocessor (`cargo run --bin preprocess`).
   - It reads `input.json`, serializes the public and private fields, and writes `input.bin` and `public.json`.
   - This step is required before running the main program, as it prepares the binary input.

2. **Build Script (`build.rs`)**
   - If you use `build.rs`, it is executed automatically by Cargo before compiling your Rust code.
   - In this project, `build.rs` is not required for the public/private input flow, but can be used for additional build-time setup if needed.

3. **Main Program (`main.rs`)**
   - You run the main program (`cargo run`).
   - It reads `input.bin` (produced by the preprocessor).
   - It extracts the public and private values, performs the computation, and outputs the result.

**Summary Table:**
| Step           | What Runs                | What It Does                                              |
|----------------|-------------------------|-----------------------------------------------------------|
| Preprocessing  | `preprocess.rs`         | Converts JSON input to binary input and public.json        |
| Build Script   | `build.rs` (optional)   | Build-time setup (not required for this flow)             |
| Main Program   | `main.rs`               | Reads binary input, computes hash, outputs public results  |

---

## How Private Values Are Handled

- **Storage**: The secret is only present in `input.json` (developer's machine) and `input.bin` (used by the program). It is never written to `public.json` or output.
- **Reference**: The main program reads the secret from bytes 8..40 of `input.bin` and uses it as the initial hash value.
- **Execution**: The secret is hashed `n` times, but never revealed or output directly.
- **Privacy**: Only the final hash (derived from the secret) is output. The secret itself is never leaked.

---

## Setup & Usage

### 1. Install dependencies
Make sure you have Rust and Cargo installed.

### 2. Define your inputs
Edit or create `input.json` in the project root:
```json
{
  "public": { "n": 5 },
  "private": { "secret": "my secret message" }
}
```

### 3. Run the preprocessor
This will generate `input.bin` and `public.json`:
```sh
cargo run --bin preprocess
```

### 4. Run the main program (on your VM or locally)
Make sure `input.bin` is available to the program:
```sh
cargo run
```

---

## Code Walkthrough

### Preprocessor (`src/bin/preprocess.rs`)
- Reads `input.json` (public & private fields)
- Pads/truncates the secret to 32 bytes
- Writes `input.bin` (public + private, as bytes)
- Writes `public.json` (public fields only)

### Main Program (`src/main.rs`)
- Reads `input.bin`
- Extracts `n` (public) and `secret` (private)
- Hashes the secret value `n` times using SHA-256
- Outputs the final hash, split into 8 public 32-bit values

---

## Security Notes
- **Never** include private values in `public.json` or any output.
- Only the public input (`n`) and the final hash are revealed.
- The secret is used only in memory and is never printed or logged.
- This structure is suitable for privacy-preserving and zero-knowledge applications.

---

## Example

1. `input.json`:
   ```json
   {
     "public": { "n": 5 },
     "private": { "secret": "my secret message" }
   }
   ```
2. Run preprocessor:
   ```sh
   cargo run --bin preprocess
   ```
3. Run main program:
   ```sh
   cargo run
   ```
4. Output (example):
   ```
   public 0: 0x...
   public 1: 0x...
   ...
   public 7: 0x...
   ```

---